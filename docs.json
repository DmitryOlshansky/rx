[
	{
		"file": "source\\rx\\algorithm\\all.d",
		"name": "rx.algorithm.all",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "all",
								"line": 414,
								"type": "AllObservable!(TObservable, pred)(auto ref TObservable observable)",
								"parameters": [
									{
										"name": "observable",
										"type": "TObservable",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 417,
								"char": 39,
								"kind": "function"
							}
						],
						"name": "all",
						"line": 414,
						"parameters": [
							{
								"name": "TObservable",
								"kind": "type"
							}
						],
						"char": 39,
						"kind": "template"
					}
				],
				"name": "all",
				"line": 412,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto sub = new SubjectObject!int;\n\nbool result = false;\nsub.all!\"a % 2 == 0\"().doSubscribe((bool res) { result = res; });\n\nsub.put(0);\nsub.completed();\nassert(result);\n\n---\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"true\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "all",
						"line": 449,
						"type": "AllObservable!TObservable(auto ref TObservable observable)",
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 452,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "all",
				"line": 449,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto sub = new SubjectObject!int;\n\nbool result = false;\nsub.all().doSubscribe((bool res) { result = res; });\n\nsub.put(0);\nsub.completed();\nassert(result);\n\n---\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					}
				],
				"char": 27,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'all'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\algorithm\\any.d",
		"name": "rx.algorithm.any",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "any",
								"line": 307,
								"type": "AnyObservable!(TObservable, pred)(auto ref TObservable observable)",
								"parameters": [
									{
										"name": "observable",
										"type": "TObservable",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 310,
								"char": 39,
								"kind": "function"
							}
						],
						"name": "any",
						"line": 307,
						"parameters": [
							{
								"name": "TObservable",
								"kind": "type"
							}
						],
						"char": 39,
						"kind": "template"
					}
				],
				"name": "any",
				"line": 305,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto sub = new SubjectObject!int;\n\nbool result = false;\nsub.any!(\"a % 2 == 0\").doSubscribe((bool) { result = true; });\n\nassert(result == false);\nsub.put(1);\nassert(result == false);\nsub.put(0);\nassert(result == true);\n\n---\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"true\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "any",
						"line": 344,
						"type": "AnyObservable!TObservable(auto ref TObservable observable)",
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 347,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "any",
				"line": 344,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto sub = new SubjectObject!int;\n\nbool result = false;\nsub.any().doSubscribe((bool) { result = true; });\n\nassert(result == false);\nsub.put(1);\nassert(result == true);\n\n---\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					}
				],
				"char": 27,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'any'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\algorithm\\filter.d",
		"name": "rx.algorithm.filter",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "filter",
								"line": 20,
								"type": "(auto ref TObservable observable)",
								"storageClass": [
									"auto"
								],
								"parameters": [
									{
										"name": "observable",
										"type": "TObservable",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 82,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "filter",
						"line": 20,
						"parameters": [
							{
								"name": "TObservable",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "filter",
				"line": 18,
				"comment": "Implements the higher order filter function. The predicate is passed to std.functional.unaryFun, and can either accept a string, or any callable that can be executed via pred(element).\nExample:\n\n---\nimport rx.subject : Subject, SubjectObject;\nimport std.array : appender;\n\nSubject!int sub = new SubjectObject!int;\nauto filtered = sub.filter!(n => n % 2 == 0);\nauto buffer = appender!(int[])();\nauto disposable = filtered.subscribe(buffer);\nscope (exit)\n    disposable.dispose();\n\nsub.put(0);\nsub.put(1);\nsub.put(2);\nsub.put(3);\n\nimport std.algorithm : equal;\n\nassert(equal(buffer.data, [0, 2][]));\n\n---\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'filter'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\algorithm\\fold.d",
		"name": "rx.algorithm.fold",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "fold",
						"line": 14,
						"type": "(auto ref TObservable observable, Seed seed)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "seed",
								"type": "Seed"
							}
						],
						"endline": 20,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "fold",
				"line": 14,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto sub = new SubjectObject!int;\nauto sum = sub.fold!\"a+b\"(0);\n\nint result = 0;\nauto disposable = sum.doSubscribe((int n) { result = n; });\nscope (exit)\n    disposable.dispose();\n\nforeach (i; 1 .. 11)\n    sub.put(i);\n\nassert(result == 0);\nsub.completed();\nassert(result == 55);\n\n---\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "TObservable",
						"kind": "type"
					},
					{
						"name": "Seed",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'fold'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\algorithm\\map.d",
		"name": "rx.algorithm.map",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "map",
								"line": 131,
								"type": "MapObservable!(f, TObservable)(auto ref TObservable observable)",
								"parameters": [
									{
										"name": "observable",
										"type": "TObservable",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 134,
								"char": 36,
								"kind": "function"
							}
						],
						"name": "map",
						"line": 131,
						"parameters": [
							{
								"name": "TObservable",
								"kind": "type"
							}
						],
						"char": 36,
						"kind": "template"
					}
				],
				"name": "map",
				"line": 129,
				"comment": "\nExample:\n\n---\nimport rx.subject;\nimport std.array : appender;\nimport std.conv : to;\n\nSubject!int sub = new SubjectObject!int;\nauto mapped = sub.map!(n => to!string(n));\nstatic assert(isObservable!(typeof(mapped), string));\nstatic assert(isSubscribable!(typeof(mapped), Observer!string));\n\nauto buffer = appender!(string[])();\nauto disposable = mapped.subscribe(buffer);\nscope (exit)\n    disposable.dispose();\n\nsub.put(0);\nsub.put(1);\nsub.put(2);\n\nimport std.algorithm : equal;\n\nassert(equal(buffer.data, [\"0\", \"1\", \"2\"][]));\n\n---\nExample:\n\n---\nimport rx.subject;\nimport std.array : appender;\nimport std.conv : to;\n\nSubject!int sub = new SubjectObject!int;\nauto mapped = sub.map!\"a * 2\";\nstatic assert(isObservable!(typeof(mapped), int));\nstatic assert(isSubscribable!(typeof(mapped), Observer!int));\n\nauto buffer = appender!(int[])();\nauto disposable = mapped.subscribe(buffer);\nscope (exit)\n    disposable.dispose();\n\nsub.put(0);\nsub.put(1);\nsub.put(2);\n\nimport std.algorithm : equal;\n\nassert(equal(buffer.data, [0, 2, 4][]));\n\n---\n",
				"parameters": [
					{
						"name": "f",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'map'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\algorithm\\merge.d",
		"name": "rx.algorithm.merge",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "merge",
						"line": 41,
						"type": "MergeObservable!(T1, T2)(auto ref T1 observable1, auto ref T2 observable2)",
						"parameters": [
							{
								"name": "observable1",
								"type": "T1",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "observable2",
								"type": "T2",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 44,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "merge",
				"line": 41,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto s1 = new SubjectObject!int;\nauto s2 = new SubjectObject!short;\n\nauto merged = s1.merge(s2);\n\nint count = 0;\nauto d = merged.doSubscribe((int n) { count++; });\n\nassert(count == 0);\ns1.put(1);\nassert(count == 1);\ns2.put(2);\nassert(count == 2);\n\nd.dispose();\n\ns1.put(10);\nassert(count == 2);\ns2.put(100);\nassert(count == 2);\n\n---\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 26,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'merge'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\algorithm\\scan.d",
		"name": "rx.algorithm.scan",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "scan",
								"line": 127,
								"type": "(auto ref TObservable observable, TAccumulate seed)",
								"storageClass": [
									"auto"
								],
								"parameters": [
									{
										"name": "observable",
										"type": "TObservable",
										"storageClass": [
											"auto",
											"ref"
										]
									},
									{
										"name": "seed",
										"type": "TAccumulate"
									}
								],
								"endline": 130,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "scan",
						"line": 127,
						"parameters": [
							{
								"name": "TObservable",
								"kind": "type"
							},
							{
								"name": "TAccumulate",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "scan",
				"line": 125,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto subject = new SubjectObject!int;\n\nauto sum = subject.scan!((a, b) => a + b)(0);\nstatic assert(isObservable!(typeof(sum), int));\n\nimport std.array : appender;\n\nauto buf = appender!(int[]);\nauto disposable = sum.subscribe(buf);\nscope (exit)\n    disposable.dispose();\n\nforeach (_; 0 .. 5)\n{\n    subject.put(1);\n}\n\nauto result = buf.data;\nassert(result.length == 5);\nimport std.algorithm : equal;\n\nassert(equal(result, [1, 2, 3, 4, 5]));\n\n---\n",
				"parameters": [
					{
						"name": "f",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'scan'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\algorithm\\tee.d",
		"name": "rx.algorithm.tee",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "tee",
								"line": 78,
								"type": "TeeObservable!(f, TObservable, TObservable.ElementType)(auto ref TObservable observable)",
								"parameters": [
									{
										"name": "observable",
										"type": "TObservable",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 82,
								"char": 61,
								"kind": "function"
							}
						],
						"name": "tee",
						"line": 78,
						"parameters": [
							{
								"name": "TObservable",
								"kind": "type"
							}
						],
						"char": 61,
						"kind": "template"
					}
				],
				"name": "tee",
				"line": 76,
				"comment": "\nExample:\n\n---\nimport rx.subject : SubjectObject;\n\nauto sub = new SubjectObject!int;\n\nimport std.array : appender;\n\nauto buf1 = appender!(int[]);\nauto buf2 = appender!(int[]);\n\nimport rx.algorithm : map;\n\nauto disposable = sub.tee!(i => buf1.put(i))().map!(i => i * 2)().subscribe(buf2);\n\nsub.put(1);\nsub.put(2);\ndisposable.dispose();\nsub.put(3);\n\nimport std.algorithm : equal;\n\nassert(equal(buf1.data, [1, 2]));\nassert(equal(buf2.data, [2, 4]));\n\n---\n",
				"parameters": [
					{
						"name": "f",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " This module defines algorithm 'tee'\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\disposable.d",
		"name": "rx.disposable",
		"members": [
			{
				"members": [
					{
						"name": "isDisposable",
						"line": 13,
						"storageClass": [
							"enum"
						],
						"deco": "b",
						"init": "is(typeof(()\r\n{\r\nT disposable = void;\r\ndisposable.dispose();\r\n}\r\n()))",
						"char": 15,
						"kind": "variable"
					}
				],
				"name": "isDisposable",
				"line": 11,
				"comment": "Tests if something is a Disposable.\nExample:\n\n---\nstruct A\n{\n    void dispose()\n    {\n    }\n}\n\nclass B\n{\n    void dispose()\n    {\n    }\n}\n\ninterface C\n{\n    void dispose();\n}\n\nstatic assert(isDisposable!A);\nstatic assert(isDisposable!B);\nstatic assert(isDisposable!C);\n\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isCancelable",
						"line": 48,
						"storageClass": [
							"enum"
						],
						"init": "isDisposable!T && is(typeof((inout int n = 0)\r\n{\r\nT disposable = void;\r\nbool b = disposable.isDisposed;\r\n}\r\n))",
						"char": 10,
						"kind": "variable"
					}
				],
				"name": "isCancelable",
				"line": 46,
				"comment": "Tests if something is a Cancelable\nExample:\n\n---\nstruct A\n{\n    bool isDisposed() @property\n    {\n        return true;\n    }\n\n    void dispose()\n    {\n    }\n}\n\nclass B\n{\n    bool isDisposed() @property\n    {\n        return true;\n    }\n\n    void dispose()\n    {\n    }\n}\n\ninterface C\n{\n    bool isDisposed() @property;\n    void dispose();\n}\n\nstatic assert(isCancelable!A);\nstatic assert(isCancelable!B);\nstatic assert(isCancelable!C);\n\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Disposable",
				"line": 92,
				"comment": "Wrapper for disposable objects.\n",
				"members": [
					{
						"name": "dispose",
						"line": 95,
						"comment": "\n",
						"storageClass": [
							"abstract"
						],
						"deco": "FZv",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "interface"
			},
			{
				"members": [
					{
						"name": "isDisposed",
						"line": 101,
						"comment": "\n",
						"storageClass": [
							"abstract"
						],
						"deco": "FNdZb",
						"char": 10,
						"kind": "function"
					}
				],
				"name": "Cancelable",
				"line": 98,
				"comment": "Wrapper for cancelable objects.\n",
				"interfaces": [
					"rx.disposable.Disposable"
				],
				"char": 1,
				"kind": "interface"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "isDisposed",
						"line": 109,
						"comment": "\n",
						"deco": "FNdZb",
						"endline": 112,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Cancelable.isDisposed"
						]
					},
					{
						"name": "isCanceled",
						"line": 114,
						"comment": "\n",
						"char": 22,
						"kind": "alias"
					},
					{
						"endchar": 5,
						"name": "dispose",
						"line": 118,
						"comment": "\n",
						"deco": "FZv",
						"endline": 121,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Disposable.dispose"
						]
					},
					{
						"name": "cancel",
						"line": 123,
						"comment": "\n",
						"char": 19,
						"kind": "alias"
					}
				],
				"name": "CancellationToken",
				"line": 105,
				"comment": "Simply implements for Cancelable interface. Its propagates notification that operations should be canceled.\n",
				"interfaces": [
					"rx.disposable.Cancelable"
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "DisposableObject",
						"line": 150,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 154,
								"comment": "\n",
								"type": "(T disposable)",
								"parameters": [
									{
										"name": "disposable",
										"type": "T"
									}
								],
								"endline": 157,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "dispose",
								"line": 161,
								"comment": "\n",
								"type": "void()",
								"endline": 164,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "DisposableObject",
				"line": 150,
				"comment": "Class that implements the Disposable interface and wraps the dispose methods in virtual functions.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CancelableObject",
						"line": 170,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 174,
								"comment": "\n",
								"type": "(T disposable)",
								"parameters": [
									{
										"name": "disposable",
										"type": "T"
									}
								],
								"endline": 177,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "isDisposed",
								"line": 181,
								"comment": "\n",
								"type": "@property bool()",
								"endline": 184,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "CancelableObject",
				"line": 170,
				"comment": "Class that implements the Cancelable interface and wraps the  isDisposed property in virtual functions.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "disposableObject",
						"line": 188,
						"type": "(T disposable)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "disposable",
								"type": "T"
							}
						],
						"endline": 204,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "disposableObject",
				"line": 188,
				"comment": "Wraps dispose method in virtual functions.\nExample:\n\n---\nint count = 0;\nstruct TestDisposable\n{\n    void dispose()\n    {\n        count++;\n    }\n}\n\nTestDisposable test;\nDisposable disposable = disposableObject(test);\nassert(count == 0);\ndisposable.dispose();\nassert(count == 1);\n\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "instance",
						"line": 288,
						"comment": "\n",
						"storageClass": [
							"static"
						],
						"deco": "FNdZC2rx10disposable10Disposable",
						"endline": 294,
						"char": 23,
						"kind": "function"
					}
				],
				"name": "NopDisposable",
				"line": 274,
				"comment": "Defines a instance property that return NOP Disposable.\nExample:\n\n---\nDisposable d1 = NopDisposable.instance;\nDisposable d2 = NopDisposable.instance;\nassert(d1 !is null);\nassert(d1 is d2);\n\n---\n",
				"interfaces": [
					"rx.disposable.Disposable"
				],
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "setDisposable",
						"line": 338,
						"comment": "\n",
						"deco": "FC2rx10disposable10DisposableZv",
						"parameters": [
							{
								"name": "disposable",
								"deco": "C2rx10disposable10Disposable"
							}
						],
						"endline": 344,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isDisposed",
						"line": 348,
						"comment": "\n",
						"deco": "FNdZb",
						"endline": 351,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Cancelable.isDisposed"
						]
					},
					{
						"endchar": 5,
						"name": "dispose",
						"line": 355,
						"comment": "\n",
						"deco": "FZv",
						"endline": 362,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Disposable.dispose"
						]
					}
				],
				"name": "SingleAssignmentDisposable",
				"line": 334,
				"comment": "\nExample:\n\n---\nint count = 0;\nclass TestDisposable : Disposable\n{\n    void dispose()\n    {\n        count++;\n    }\n}\n\nauto temp = new SingleAssignmentDisposable;\ntemp.setDisposable(new TestDisposable);\nassert(!temp.isDisposed);\nassert(count == 0);\ntemp.dispose();\nassert(temp.isDisposed);\nassert(count == 1);\n\n---\n",
				"interfaces": [
					"rx.disposable.Cancelable"
				],
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "isDisposed",
						"line": 428,
						"comment": "\n",
						"deco": "FNdZb",
						"endline": 431,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Cancelable.isDisposed"
						]
					},
					{
						"endchar": 5,
						"name": "disposable",
						"line": 434,
						"comment": "\n",
						"deco": "FNdC2rx10disposable10DisposableZv",
						"parameters": [
							{
								"name": "value",
								"deco": "C2rx10disposable10Disposable"
							}
						],
						"endline": 451,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "disposable",
						"line": 454,
						"comment": "\n",
						"deco": "FNdZC2rx10disposable10Disposable",
						"endline": 457,
						"char": 16,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dispose",
						"line": 461,
						"comment": "\n",
						"deco": "FZv",
						"endline": 475,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Disposable.dispose"
						]
					}
				],
				"name": "SerialDisposable",
				"line": 418,
				"comment": "\n",
				"interfaces": [
					"rx.disposable.Cancelable"
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "signal",
						"line": 534,
						"comment": "\n",
						"deco": "FNdZC2rx4util11EventSignal",
						"endline": 537,
						"char": 17,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dispose",
						"line": 541,
						"comment": "\n",
						"deco": "FZv",
						"endline": 544,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Disposable.dispose"
						]
					}
				],
				"name": "SignalDisposable",
				"line": 524,
				"comment": "\n",
				"interfaces": [
					"rx.disposable.Disposable"
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"originalType": "(Disposable[] disposables...)",
						"name": "this",
						"line": 564,
						"comment": "\n",
						"deco": "FAC2rx10disposable10DisposableXC2rx10disposable19CompositeDisposable",
						"parameters": [
							{
								"name": "disposables",
								"deco": "AC2rx10disposable10Disposable"
							}
						],
						"endline": 567,
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "dispose",
						"line": 571,
						"comment": "\n",
						"deco": "FZv",
						"endline": 575,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Disposable.dispose"
						]
					}
				],
				"name": "CompositeDisposable",
				"line": 560,
				"comment": "\nExample:\n\n---\nauto d1 = new SingleAssignmentDisposable;\nauto d2 = new SerialDisposable;\nauto d = new CompositeDisposable(d1, d2);\nd.dispose();\n\n---\n",
				"interfaces": [
					"rx.disposable.Disposable"
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"originalType": "(void delegate() dispose)",
						"name": "this",
						"line": 594,
						"comment": "\n",
						"deco": "FDFZvZC2rx10disposable20AnonymouseDisposable",
						"parameters": [
							{
								"name": "dispose",
								"deco": "DFZv"
							}
						],
						"endline": 598,
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "dispose",
						"line": 602,
						"comment": "\n",
						"deco": "FZv",
						"endline": 609,
						"char": 10,
						"kind": "function",
						"overrides": [
							"rx.disposable.Disposable.dispose"
						]
					}
				],
				"name": "AnonymouseDisposable",
				"line": 590,
				"comment": "\nExample:\n\n---\nint count = 0;\nauto d = new AnonymouseDisposable({ count++; });\nassert(count == 0);\nd.dispose();\nassert(count == 1);\nd.dispose();\nassert(count == 1);\n\n---\n",
				"interfaces": [
					"rx.disposable.Disposable"
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " This module defines the concept of Disposable.\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\observable.d",
		"name": "rx.observable",
		"members": [
			{
				"members": [
					{
						"name": "isObservable",
						"line": 16,
						"storageClass": [
							"enum"
						],
						"deco": "b",
						"init": "is(T.ElementType : E) && is(typeof(()\r\n{\r\nT observable = void;\r\nObserver!E observer = void;\r\nauto d = observable.subscribe(observer);\r\nstatic assert(isDisposable!(typeof(d)));\r\n}\r\n()))",
						"char": 15,
						"kind": "variable"
					}
				],
				"name": "isObservable",
				"line": 14,
				"comment": "Tests if something is a Observable.\nExample:\n\n---\nstruct TestObservable\n{\n    alias ElementType = int;\n\n    Disposable subscribe(T)(T observer)\n    {\n        static assert(isObserver!(T, int));\n        return null;\n    }\n}\n\nstatic assert(isObservable!(TestObservable, int));\nstatic assert(!isObservable!(TestObservable, Object));\n\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSubscribable",
						"line": 44,
						"storageClass": [
							"enum"
						],
						"deco": "b",
						"init": "is(typeof(()\r\n{\r\nTObservable observable = void;\r\nTObserver observer = void;\r\nauto d = observable.subscribe(observer);\r\nstatic assert(isDisposable!(typeof(d)));\r\n}\r\n()))",
						"char": 15,
						"kind": "variable"
					}
				],
				"name": "isSubscribable",
				"line": 42,
				"comment": "Test if the observer can subscribe to the observable.\nExample:\n\n---\nstruct TestDisposable\n{\n    void dispose()\n    {\n    }\n}\n\nstruct TestObserver\n{\n    void put(int n)\n    {\n    }\n\n    void completed()\n    {\n    }\n\n    void failure(Exception e)\n    {\n    }\n}\n\nstruct TestObservable\n{\n    TestDisposable subscribe(TestObserver observer)\n    {\n        return TestDisposable();\n    }\n}\n\nstatic assert(isSubscribable!(TestObservable, TestObserver));\n\n---\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					},
					{
						"name": "TObserver",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "doSubscribe",
						"line": 88,
						"type": "(auto ref TObservable observable, void delegate(E) doPut, void delegate() doCompleted, void delegate(Exception) doFailure)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "doPut",
								"type": "void delegate(E)"
							},
							{
								"name": "doCompleted",
								"type": "void delegate()"
							},
							{
								"name": "doFailure",
								"type": "void delegate(Exception)"
							}
						],
						"endline": 92,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "doSubscribe",
				"line": 88,
				"comment": "The helper for subscribe easier.\nExample:\n\n---\nstruct TestObserver\n{\n    void put(int n)\n    {\n    }\n}\n\nstruct TestObservable1\n{\n    alias ElementType = int;\n    Disposable subscribe(Observer!int observer)\n    {\n        return null;\n    }\n}\n\nstruct TestObservable2\n{\n    alias ElementType = int;\n    Disposable subscribe(T)(T observer)\n    {\n        return null;\n    }\n}\n\nTestObservable1 o1;\nauto d0 = o1.doSubscribe((int n) {  }, () {  }, (Exception e) {  });\nauto d1 = o1.doSubscribe((int n) {  }, () {  });\nauto d2 = o1.doSubscribe((int n) {  }, (Exception e) {  });\nauto d3 = o1.doSubscribe((int n) {  });\nauto d4 = o1.doSubscribe(TestObserver());\nTestObservable2 o2;\nauto d5 = o2.doSubscribe((int n) {  }, () {  }, (Exception e) {  });\nauto d6 = o2.doSubscribe((int n) {  }, () {  });\nauto d7 = o2.doSubscribe((int n) {  }, (Exception e) {  });\nauto d8 = o2.doSubscribe((int n) {  });\nauto d9 = o2.doSubscribe(TestObserver());\n\n---\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "doSubscribe",
						"line": 94,
						"type": "(auto ref TObservable observable, void delegate(E) doPut, void delegate() doCompleted)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "doPut",
								"type": "void delegate(E)"
							},
							{
								"name": "doCompleted",
								"type": "void delegate()"
							}
						],
						"endline": 98,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "doSubscribe",
				"line": 94,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "doSubscribe",
						"line": 100,
						"type": "(auto ref TObservable observable, void delegate(E) doPut, void delegate(Exception) doFailure)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "doPut",
								"type": "void delegate(E)"
							},
							{
								"name": "doFailure",
								"type": "void delegate(Exception)"
							}
						],
						"endline": 104,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "doSubscribe",
				"line": 100,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "doSubscribe",
						"line": 106,
						"type": "(auto ref TObservable observable, auto ref TObserver observer)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "observer",
								"type": "TObserver",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 115,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "doSubscribe",
				"line": 106,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					},
					{
						"name": "TObserver",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Observable",
						"line": 159,
						"members": [],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "Observable",
				"line": 159,
				"comment": "Wrapper for Observable objects.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ObservableObject",
						"line": 172,
						"members": [],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "ObservableObject",
				"line": 172,
				"comment": "Class that implements Observable interface and wraps the subscribe method in virtual function.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "observableObject",
								"line": 193,
								"type": "Observable!E(auto ref R observable)",
								"parameters": [
									{
										"name": "observable",
										"type": "R",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 203,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "observableObject",
						"line": 193,
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 18,
						"kind": "template"
					}
				],
				"name": "observableObject",
				"line": 191,
				"comment": "Wraps subscribe method in virtual function.\nExample:\n\n---\nint subscribeCount = 0;\nclass TestObservable : Observable!int\n{\n    Disposable subscribe(Observer!int observer)\n    {\n        subscribeCount++;\n        return NopDisposable.instance;\n    }\n}\n\nauto test = new TestObservable;\nauto observable = observableObject!int(test);\nassert(observable is test);\nassert(subscribeCount == 0);\nauto d = observable.subscribe(null);\nassert(subscribeCount == 1);\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "defer",
						"line": 261,
						"type": "()",
						"storageClass": [
							"auto"
						],
						"endline": 339,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "defer",
				"line": 261,
				"comment": "Create observable by function that template parameter.\nExample:\n\n---\nauto sub = defer!(int, (observer) {\n    observer.put(1);\n    observer.put(2);\n    observer.put(3);\n    observer.completed();\n});\n\nint countPut = 0;\nint countCompleted = 0;\nstruct A\n{\n    void put(int n)\n    {\n        countPut++;\n    }\n\n    void completed()\n    {\n        countCompleted++;\n    }\n}\n\nassert(countPut == 0);\nassert(countCompleted == 0);\nauto d = sub.doSubscribe(A());\nassert(countPut == 3);\nassert(countCompleted == 1);\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "f",
						"kind": "alias"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " This module defines the concept of Observable.\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\observer.d",
		"name": "rx.observer",
		"members": [
			{
				"members": [
					{
						"name": "hasCompleted",
						"line": 13,
						"storageClass": [
							"enum"
						],
						"deco": "b",
						"init": "is(typeof(()\r\n{\r\nT observer = void;\r\nobserver.completed();\r\n}\r\n()))",
						"char": 15,
						"kind": "variable"
					}
				],
				"name": "hasCompleted",
				"line": 10,
				"comment": "Tests if something has completed method.\nExample:\n\n---\nstruct A\n{\n    void completed();\n}\n\nstruct B\n{\n    void _completed();\n}\n\nstatic assert(hasCompleted!A);\nstatic assert(!hasCompleted!B);\n\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasFailure",
						"line": 40,
						"storageClass": [
							"enum"
						],
						"deco": "b",
						"init": "is(typeof(()\r\n{\r\nT observer = void;\r\nException e = void;\r\nobserver.failure(e);\r\n}\r\n()))",
						"char": 15,
						"kind": "variable"
					}
				],
				"name": "hasFailure",
				"line": 37,
				"comment": "Tests if something has failure method.\nExample:\n\n---\nstruct A\n{\n    void failure(Exception e);\n}\n\nstruct B\n{\n    void _failure(Exception e);\n}\n\nstruct C\n{\n    void failure();\n}\n\nstatic assert(hasFailure!A);\nstatic assert(!hasFailure!B);\nstatic assert(!hasFailure!C);\n\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isObserver",
						"line": 73,
						"storageClass": [
							"enum"
						],
						"deco": "b",
						"init": "isOutputRange!(T, E) && hasCompleted!T && hasFailure!T",
						"char": 15,
						"kind": "variable"
					}
				],
				"name": "isObserver",
				"line": 71,
				"comment": "Tests if something is Observer.\nExample:\n\n---\nstruct TestObserver\n{\n    void put(int n)\n    {\n    }\n\n    void completed()\n    {\n    }\n\n    void failure(Exception e)\n    {\n    }\n}\n\nstatic assert(isObserver!(TestObserver, int));\n\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Observer",
						"line": 97,
						"members": [
							{
								"name": "completed",
								"line": 100,
								"comment": "\n",
								"type": "void()",
								"char": 10,
								"kind": "function"
							},
							{
								"name": "failure",
								"line": 102,
								"comment": "\n",
								"type": "void(Exception e)",
								"parameters": [
									{
										"name": "e",
										"type": "Exception"
									}
								],
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "Observer",
				"line": 97,
				"comment": "Wraps completed and failure method in virtual function.\nExample:\n\n---\nalias TObserver = Observer!byte;\nstatic assert(isObserver!(TObserver, byte));\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ObserverObject",
						"line": 112,
						"members": [
							{
								"endchar": 5,
								"name": "completed",
								"line": 123,
								"comment": "\n",
								"type": "void()",
								"endline": 129,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "failure",
								"line": 131,
								"comment": "\n",
								"type": "void(Exception e)",
								"parameters": [
									{
										"name": "e",
										"type": "Exception"
									}
								],
								"endline": 137,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "ObserverObject",
				"line": 112,
				"comment": "Class that implements Observer interface and wraps the completed and failure method in virtual functions. This class extends the OutputRangeObject.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "observerObject",
								"line": 146,
								"type": "ObserverObject!(R, E)(R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 149,
								"char": 27,
								"kind": "function"
							}
						],
						"name": "observerObject",
						"line": 146,
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 27,
						"kind": "template"
					}
				],
				"name": "observerObject",
				"line": 144,
				"comment": "Wraps subscribe method in virtual function.\nExample:\n\n---\nstruct TestObserver\n{\n    void put(int n)\n    {\n    }\n\n    void put(Object obj)\n    {\n    }\n}\n\nObserver!int observer = observerObject!int(TestObserver());\nobserver.put(0);\nobserver.completed();\nobserver.failure(null);\nstatic assert(isObserver!(typeof(observer), int));\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NopObserver",
						"line": 310,
						"members": [
							{
								"endchar": 5,
								"name": "instance",
								"line": 332,
								"comment": "\n",
								"storageClass": [
									"static"
								],
								"type": "Observer!E()",
								"endline": 338,
								"char": 23,
								"kind": "function"
							}
						],
						"char": 7,
						"kind": "class"
					}
				],
				"name": "NopObserver",
				"line": 310,
				"comment": "\nExample:\n\n---\nObserver!int o1 = NopObserver!int.instance;\nObserver!int o2 = NopObserver!int.instance;\nassert(o1 !is null);\nassert(o1 is o2);\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "DoneObserver",
						"line": 350,
						"members": [],
						"char": 7,
						"kind": "class"
					}
				],
				"name": "DoneObserver",
				"line": 350,
				"comment": "\nExample:\n\n---\nObserver!int o1 = DoneObserver!int.instance;\nObserver!int o2 = DoneObserver!int.instance;\nassert(o1 !is null);\nassert(o1 is o2);\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CompositeObserver",
						"line": 414,
						"members": [
							{
								"endchar": 5,
								"name": "put",
								"line": 429,
								"comment": "\n",
								"type": "void(E obj)",
								"parameters": [
									{
										"name": "obj",
										"type": "E"
									}
								],
								"endline": 433,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "completed",
								"line": 435,
								"comment": "\n",
								"type": "void()",
								"endline": 439,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "failure",
								"line": 441,
								"comment": "\n",
								"type": "void(Exception e)",
								"parameters": [
									{
										"name": "e",
										"type": "Exception"
									}
								],
								"endline": 445,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "add",
								"line": 447,
								"comment": "\n",
								"type": "CompositeObserver!E(Observer!E observer)",
								"parameters": [
									{
										"name": "observer",
										"type": "Observer!E"
									}
								],
								"endline": 450,
								"char": 25,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "remove",
								"line": 452,
								"comment": "\n",
								"type": "Observer!E(Observer!E observer)",
								"parameters": [
									{
										"name": "observer",
										"type": "Observer!E"
									}
								],
								"endline": 466,
								"char": 16,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 470,
								"comment": "\n",
								"storageClass": [
									"static"
								],
								"type": "CompositeObserver!E()",
								"endline": 476,
								"char": 32,
								"kind": "function"
							}
						],
						"char": 8,
						"kind": "class"
					}
				],
				"name": "CompositeObserver",
				"line": 414,
				"comment": "\nExample:\n\n---\nint count = 0;\nstruct TestObserver\n{\n    void put(int n)\n    {\n        count++;\n    }\n}\n\nauto c1 = new CompositeObserver!int;\nc1.put(0);\nauto o1 = observerObject!int(TestObserver());\nauto c2 = c1.add(o1);\nc1.put(0);\nassert(count == 0);\nc2.put(0);\nassert(count == 1);\nauto c3 = c2.add(observerObject!int(TestObserver()));\nc3.put(0);\nassert(count == 3);\nauto c4 = c3.remove(o1);\nc4.put(0);\nassert(count == 4);\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeObserver",
						"line": 527,
						"type": "(void delegate(E) doPut, void delegate() doCompleted, void delegate(Exception) doFailure)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "doPut",
								"type": "void delegate(E)"
							},
							{
								"name": "doCompleted",
								"type": "void delegate()"
							},
							{
								"name": "doFailure",
								"type": "void delegate(Exception)"
							}
						],
						"endline": 566,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "makeObserver",
				"line": 527,
				"comment": "The helper for the own observer.\nExample:\n\n---\nint countPut = 0;\nint countCompleted = 0;\nint countFailure = 0;\n\nauto observer = makeObserver((int) { countPut++; }, () { countCompleted++; }, (Exception) {\n    countFailure++;\n});\n\n.put(observer, 0);\nassert(countPut == 1);\n\nobserver.completed();\nassert(countCompleted == 1);\n\nobserver.failure(null);\nassert(countFailure == 1);\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeObserver",
						"line": 568,
						"type": "(void delegate(E) doPut, void delegate() doCompleted)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "doPut",
								"type": "void delegate(E)"
							},
							{
								"name": "doCompleted",
								"type": "void delegate()"
							}
						],
						"endline": 598,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "makeObserver",
				"line": 568,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeObserver",
						"line": 600,
						"type": "(void delegate(E) doPut, void delegate(Exception) doFailure)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "doPut",
								"type": "void delegate(E)"
							},
							{
								"name": "doFailure",
								"type": "void delegate(Exception)"
							}
						],
						"endline": 630,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "makeObserver",
				"line": 600,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " This module defines the concept of Observer.\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\range.d",
		"name": "rx.range",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "drop",
						"line": 43,
						"type": "(auto ref TObservable observable, size_t n)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 113,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "drop",
				"line": 43,
				"comment": "Creates the observable that results from discarding the first n elements from the given source.\nExample:\n\n---\nimport rx.subject;\n\nauto subject = new SubjectObject!int;\nauto dropped = subject.drop(1);\nstatic assert(isObservable!(typeof(dropped), int));\n\nimport std.array : appender;\n\nauto buf = appender!(int[]);\nauto disposable = dropped.subscribe(buf);\n\nsubject.put(0);\nassert(buf.data.length == 0);\nsubject.put(1);\nassert(buf.data.length == 1);\n\nauto buf2 = appender!(int[]);\ndropped.subscribe(buf2);\nassert(buf2.data.length == 0);\nsubject.put(2);\nassert(buf2.data.length == 0);\nassert(buf.data.length == 2);\nsubject.put(3);\nassert(buf2.data.length == 1);\nassert(buf.data.length == 3);\n\n---\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "take",
						"line": 165,
						"type": "(auto ref TObservable observable, size_t n)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 254,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "take",
				"line": 165,
				"comment": "Creates a sub-observable consisting of only up to the first n elements of the given source.\nExample:\n\n---\nimport std.array;\nimport rx.subject;\n\nauto pub = new SubjectObject!int;\nauto sub = appender!(int[]);\n\nauto d = pub.take(2).subscribe(sub);\nforeach (i; 0 .. 10)\n{\n    pub.put(i);\n}\n\nimport std.algorithm;\n\nassert(equal(sub.data, [0, 1]));\n\n---\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeLast",
						"line": 340,
						"type": "(auto ref TObservable observable)",
						"storageClass": [
							"auto"
						],
						"parameters": [
							{
								"name": "observable",
								"type": "TObservable",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 410,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "takeLast",
				"line": 340,
				"comment": "Creates a observable that take only a last element of the given source.\nExample:\n\n---\nimport rx.subject;\n\nauto sub = new SubjectObject!int;\n\nint putCount = 0;\nint completedCount = 0;\nstruct TestObserver\n{\n    void put(int n)\n    {\n        putCount++;\n    }\n\n    void completed()\n    {\n        completedCount++;\n    }\n}\n\nauto d = sub.takeLast.subscribe(TestObserver());\n\nassert(putCount == 0);\nsub.put(1);\nassert(putCount == 0);\nsub.put(10);\nassert(putCount == 0);\nsub.completed();\nassert(putCount == 1);\nassert(completedCount == 1);\n\nsub.put(100);\nassert(putCount == 1);\nassert(completedCount == 1);\n\n---\n",
				"parameters": [
					{
						"name": "TObservable",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " This module defines some operations like range.\nExample:\nOverview\n---\nimport rx.subject;\nimport std.algorithm : equal;\nimport std.array : appender;\nimport std.conv : to;\n\nauto subject = new SubjectObject!int;\nauto pub = subject.drop(2).take(3);\n\nauto buf = appender!(int[]);\nauto disposable = pub.subscribe(observerObject!int(buf));\n\nforeach (i; 0 .. 10)\n{\n    subject.put(i);\n}\n\nauto result = buf.data;\nassert(equal(result, [2, 3, 4]));\n\n---\n",
		"kind": "module"
	},
	{
		"file": "source\\rx\\subject.d",
		"name": "rx.subject",
		"members": [
			{
				"members": [
					{
						"name": "Subject",
						"line": 14,
						"members": [],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "Subject",
				"line": 14,
				"comment": "Represents an object that is both an observable sequence as well as an observer.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SubjectObject",
						"line": 19,
						"members": [
							{
								"endchar": 5,
								"name": "put",
								"line": 30,
								"comment": "\n",
								"type": "void(E obj)",
								"parameters": [
									{
										"name": "obj",
										"type": "E"
									}
								],
								"endline": 34,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "completed",
								"line": 36,
								"comment": "\n",
								"type": "void()",
								"endline": 50,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "failure",
								"line": 52,
								"comment": "\n",
								"type": "void(Exception error)",
								"parameters": [
									{
										"name": "error",
										"type": "Exception"
									}
								],
								"endline": 66,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "subscribe",
										"line": 69,
										"type": "Disposable(T observer)",
										"parameters": [
											{
												"name": "observer",
												"type": "T"
											}
										],
										"endline": 72,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "subscribe",
								"line": 69,
								"comment": "\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 16,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "subscribe",
								"line": 74,
								"comment": "\n",
								"type": "Disposable(Observer!E observer)",
								"parameters": [
									{
										"name": "observer",
										"type": "Observer!E"
									}
								],
								"endline": 111,
								"char": 16,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "unsubscribe",
								"line": 114,
								"comment": "\n",
								"type": "void(Observer!E observer)",
								"parameters": [
									{
										"name": "observer",
										"type": "Observer!E"
									}
								],
								"endline": 136,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "SubjectObject",
				"line": 19,
				"comment": "Represents an object that is both an observable sequence as well as an observer. Each notification is broadcasted to all subscribed observers.\nExample:\n\n---\nimport std.array : appender;\n\nauto data = appender!(int[])();\nauto subject = new SubjectObject!int;\nauto disposable = subject.subscribe(observerObject!(int)(data));\nassert(disposable !is null);\nsubject.put(0);\nsubject.put(1);\n\nimport std.algorithm : equal;\n\nassert(equal(data.data, [0, 1]));\n\ndisposable.dispose();\nsubject.put(2);\nassert(equal(data.data, [0, 1]));\n\n---\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " This module defines the Subject and some implements.\n",
		"kind": "module"
	}
]